자 내가 문서를 다시 줄게 테라폼만 하는거야 테라폼만 

Terraform 전용 CI 구성(Phase 4-4)

1) 디렉터리 구조

/
├─ 02-terraform/                  # ← Terraform 코드
├─ 03-GitLab/
│  └─ Runners/
│     └─ terraform.ci.yml         # ← Terraform 전용 CI 정의(실제 내용은 여기)
└─ .gitlab-ci.yml                 # ← 루트: include 전용(이 파일만 GitLab이 자동 인식)


2) 루트 .gitlab-ci.yml (include 전용)

주의: 지금은 Terraform만 포함합니다. Ansible은 나중(4-5) 추가.

# /.gitlab-ci.yml
include:
  - local: '03-GitLab/Runners/terraform.ci.yml'


3) 03-GitLab/Runners/terraform.ci.yml

dev = plan 자동, main = 수동 apply, destroy 수동. 작업 디렉터리는 02-terraform.

stages: [plan, apply, destroy]

variables:
  TF_WORKDIR: "02-terraform"
  TF_IN_AUTOMATION: "1"

# (선택) init 속도 향상: 플러그인 캐시
cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - 02-terraform/.terraform/

before_script:
  # OpenStack 인증 (clouds.yaml 사용 시)
  - export OS_CLIENT_CONFIG_FILE="$HOME/.config/openstack/clouds.yaml"
  - export OS_CLOUD="dev"    # ← clouds.yaml의 cloud 이름과 반드시 일치
  - cd "$TF_WORKDIR"
  - terraform -version
  - terraform init -input=false

# dev에서 terraform 변경 시 plan 자동
tf:plan:
  stage: plan
  script:
    - terraform fmt -check
    - terraform validate
    - terraform plan -input=false -detailed-exitcode -out=tfplan || export TF_EXIT=$?
    - if [ "${TF_EXIT:-0}" = "1" ]; then echo "terraform plan error"; exit 1; fi
    - if [ "${TF_EXIT:-0}" = "0" ]; then echo "No changes"; exit 0; fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
      changes:
        - "02-terraform/**/*"
    - when: never
  artifacts:
    paths: [ "02-terraform/tfplan" ]
    expire_in: 1 day

# main에서만: 같은 파이프라인 안에서 plan → apply (수동 승인)
tf:apply:
  stage: apply
  resource_group: "terraform-apply"   # 동시 적용 충돌 방지
  script:
    - terraform plan -input=false -out=tfplan
    - terraform apply -input=false -auto-approve tfplan
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
      changes:
        - "02-terraform/**/*"
    - when: never
  environment:
    name: production

# main에서만: 전체 삭제(항상 수동)
tf:destroy:
  stage: destroy
  resource_group: "terraform-apply"
  script:
    - terraform destroy -auto-approve
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - when: never
  allow_failure: false
  environment:
    name: production
    action: stop


4) Runner 인증(택1)

방법 A: clouds.yaml (지금 사용하는 방식)

sudo -u gitlab-runner mkdir -p ~gitlab-runner/.config/openstack
sudo cp ~/.config/openstack/clouds.yaml ~gitlab-runner/.config/openstack/
sudo chown gitlab-runner:gitlab-runner ~gitlab-runner/.config/openstack/clouds.yaml
sudo chmod 600 ~gitlab-runner/.config/openstack/clouds.yaml


위 파일의 cloud 이름 ↔ OS_CLOUD 값 일치 필수.

방법 B: GitLab Variables

Settings → CI/CD → Variables에 OS_AUTH_URL, OS_USERNAME … 등 등록

(현재는 A 사용이므로 선택사항)

5) 권장 설정 체크리스트

GitLab에서 main을 Protected branch로 설정

(선택) 원격 state 구성(02-terraform/terraform/backend.tf) → state 분실·동시 실행 충돌 방지

Runner 유저가 OpenStack에 접근 가능한지 확인(openstack --version, 권한 OK)

첫 실행은 dev에서 02-terraform 폴더 안 파일을 살짝 수정해 plan 자동 트리거로 확인

이거 가독성올려서 정리해줘
