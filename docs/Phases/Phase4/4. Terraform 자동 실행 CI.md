# GitLab CI 파이프라인 통합 관리 가이드

**목적**: 코드 변경 → GitLab CI → Terraform/Ansible 자동 실행  
**범위**: 분리된 구조로 Terraform과 Ansible CI를 독립적으로 관리

---

## 전제 조건

### 필수 환경
- GitLab CE 동작 중 (예: `http://a.b.c.d:8081`)
- Shell Runner 등록 및 동작 확인 완료
- OpenStack 환경 구성 완료

### 프로젝트 구조 (분리 + include 방식)
```
/
├─ 01-ansible/                 # Ansible 플레이북/스크립트
├─ 02-terraform/               # Terraform 코드
├─ 03-GitLab/
│  └─ Runners/                 # CI 정의 모음 (여기서만 관리)
│     ├─ ansible.ci.yml        # Ansible 전용 CI 정의
│     ├─ terraform.ci.yml      # Terraform 전용 CI 정의
│     └─ test.ci.yml           # (선택) 테스트용 CI 정의
└─ .gitlab-ci.yml              # 루트, include 전용 (최종 1개만 실행됨)
```

### Runner OpenStack 인증 준비

**방법 1: clouds.yaml 파일**
```bash
# gitlab-runner 사용자 홈 디렉토리에 설정
sudo -u gitlab-runner mkdir -p ~/.config/openstack
sudo cp ~/.config/openstack/clouds.yaml ~gitlab-runner/.config/openstack/
sudo chown gitlab-runner:gitlab-runner ~gitlab-runner/.config/openstack/clouds.yaml
sudo chmod 600 ~gitlab-runner/.config/openstack/clouds.yaml
```

**방법 2: GitLab CI/CD Variables**
- GitLab → Settings → CI/CD → Variables에서 OpenStack 인증 변수 등록

**권장: 원격 state 사용**
- `terraform/backend.tf`로 원격 state 구성 (state 분실 방지)

---

## 실행 전략

| 브랜치 | 조건 | Terraform | Ansible |
|--------|------|-----------|---------|
| `dev` | 해당 폴더 변경 시 | **plan 자동 실행** | **test 자동 실행** |
| `main` | 해당 폴더 변경 시 | **apply 수동 승인** | **deploy 수동 승인** |
| 모든 브랜치 | 수동 실행 | **destroy 수동 실행** | - |

---

## CI 파이프라인 구성

### 루트 .gitlab-ci.yml (include 전용)
```yaml
# /.gitlab-ci.yml
include:
  - local: '03-GitLab/Runners/terraform.ci.yml'
  - local: '03-GitLab/Runners/ansible.ci.yml'
  # - local: '03-GitLab/Runners/test.ci.yml'   # 필요할 때만 활성화
```

### Terraform CI 정의 (03-GitLab/Runners/terraform.ci.yml)
```yaml
stages: [plan, apply, destroy]

variables:
  TF_WORKDIR: "02-terraform"
  TF_IN_AUTOMATION: "1"

before_script:
  - export OS_CLIENT_CONFIG_FILE="$HOME/.config/openstack/clouds.yaml"
  - export OS_CLOUD="dev"
  - cd "$TF_WORKDIR"
  - terraform -version
  - terraform init -input=false

tf:plan:
  stage: plan
  script:
    - terraform fmt -check
    - terraform validate
    - terraform plan -input=false -detailed-exitcode -out=tfplan || export TF_EXIT=$?
    - if [ "${TF_EXIT:-0}" = "1" ]; then echo "terraform plan error"; exit 1; fi
    - if [ "${TF_EXIT:-0}" = "0" ]; then echo "No changes"; exit 0; fi
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
      changes:
        - "02-terraform/**/*"
    - when: never
  artifacts:
    paths: [ "02-terraform/tfplan" ]
    expire_in: 1 day

tf:apply:
  stage: apply
  resource_group: "terraform-apply"
  script:
    - terraform plan -input=false -out=tfplan
    - terraform apply -input=false -auto-approve tfplan
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
      changes:
        - "02-terraform/**/*"
    - when: never
  environment:
    name: production

tf:destroy:
  stage: destroy
  resource_group: "terraform-apply"
  script:
    - terraform destroy -auto-approve
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
    - when: never
  allow_failure: false
  environment:
    name: production
    action: stop
```

### Ansible CI 정의 (03-GitLab/Runners/ansible.ci.yml)
```yaml
stages: [deploy, test]

variables:
  ANSIBLE_WORKDIR: "01-ansible"

before_script:
  - cd "$ANSIBLE_WORKDIR"

ansible:deploy:
  stage: deploy
  script:
    - ansible-playbook -i ../inventory site.yml
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
      changes:
        - "01-ansible/**/*"
    - when: never
  environment:
    name: production

ansible:test:
  stage: test
  script:
    - ansible-playbook -i ../inventory test.yml
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
      changes:
        - "01-ansible/**/*"
    - when: never
```

---

## 구성 설계 이유

### 분리 관리 방식의 장점
- **독립적 관리**: Terraform과 Ansible CI 정의를 각각 관리
- **코드 충돌 방지**: 루트는 include만, 실제 정의는 분리
- **확장성**: 새로운 CI 정의 추가 시 include만 수정
- **백업 용이**: 각 CI 정의별로 독립적 버전 관리

### Rules와 Changes 사용
- `rules: changes:` → 해당 폴더 변경 없으면 job 자체가 생성되지 않음
- 불필요한 파이프라인 실행 방지로 리소스 절약

### Detailed Exit Code 활용 (Terraform)
- `-detailed-exitcode` → 변경 없으면 빠르게 종료
- 0: 변경 없음, 1: 오류, 2: 변경 있음으로 구분

### Resource Group 사용
- `resource_group` → 동일한 리소스에 대한 동시 실행 방지
- Terraform apply/destroy의 상태 충돌 방지

### Manual 실행
- `apply`, `destroy`, `deploy`는 수동 실행으로 실수 방지
- 필요 시 `on_stop`으로 Environments Stop 버튼 연결 가능

---

## 운영 원칙

1. **실행은 루트만**
   - GitLab이 읽는 건 루트 `.gitlab-ci.yml` 단 하나
   - 나머지(`03-GitLab/Runners/*.ci.yml`)는 단순 "정의 파일"일 뿐

2. **관리/백업 분리**
   - Terraform/Ansible CI 정의는 `03-GitLab/Runners` 안에서만 관리
   - 루트는 include용이므로 코드 충돌 위험 없음

3. **rules:changes 활용**
   - Terraform 코드(`02-terraform/**/*`)가 바뀌면 Terraform 잡만
   - Ansible 코드(`01-ansible/**/*`)가 바뀌면 Ansible 잡만 실행

4. **테스트용 CI**
   - `test.ci.yml`은 필요할 때만 루트 include에 추가/제거
   - 운영 파이프라인에 영향을 주지 않음

---

## 사용법

### 1. 개발 단계 (Plan/Test 확인)

**Terraform 변경**
```bash
git checkout dev
git add 02-terraform/*
git commit -m "feat(terraform): VM 인스턴스 추가"
git push origin dev
```

**Ansible 변경**
```bash
git checkout dev
git add 01-ansible/*
git commit -m "feat(ansible): 새로운 플레이북 추가"
git push origin dev
```

> 파이프라인에서 해당 `plan` 또는 `test` 잡이 자동 실행되어 변경 내역 확인 가능

### 2. 운영 반영 (Apply/Deploy 실행)
```bash
git checkout main
git merge dev
git push origin main
```

> 파이프라인에서 해당 `apply` 또는 `deploy` **수동 승인** 클릭하여 실행

### 3. 리소스 삭제 (Destroy 실행)
- 파이프라인에서 `tf:destroy` 수동 실행
- (선택) Environments Stop 버튼 사용 시 `tf:apply.environment.on_stop` 주석 해제

---

## 트러블슈팅

### > 코드 받기 타임아웃 문제
**GitLab 설정 확인**
```bash
# GitLab external_url 확인
sudo gitlab-rails runner 'puts Gitlab.config.gitlab.url'

# Runner clone_url 확인
sudo gitlab-runner list
```

### > OpenStack 인증 오류
**clouds.yaml 경로 및 권한 확인**
```bash
# 파일 존재 및 권한 확인
ls -la ~gitlab-runner/.config/openstack/clouds.yaml
sudo -u gitlab-runner openstack --os-cloud devstack server list
```

**도메인/프로젝트 값 재검토**
```bash
# openrc에서 정확한 값 확인
source /opt/stack/devstack/openrc admin
env | grep OS_
```

### > Apply 실패 (불변 속성 오류)
**Plan에서 재생성 확인**
- Plan 단계에서 Destroy+Create 표시 확인
- 불변 속성 변경 시 리소스 재생성 필요함을 인지

### > State 관리 문제
**원격 State 백엔드 사용 권장**
```hcl
# backend.tf 예시
terraform {
  backend "local" {
    path = "/shared/terraform/terraform.tfstate"
  }
}
```

### > Job 실행되지 않는 문제
**Runner 태그 확인**
- `.gitlab-ci.yml`에서 tags 설정 확인
- Runner 등록 시 설정한 태그와 일치해야 함

**Changes 조건 확인**
- 해당 폴더 내 파일 변경이 있어야 job 실행
- Git diff로 변경 사항 확인

### > Include 파일을 찾을 수 없는 오류
**파일 경로 확인**
```bash
# 파일 존재 확인
ls -la 03-GitLab/Runners/
```

**상대 경로 수정**
- `local:` 경로는 프로젝트 루트 기준
- 파일명과 확장자 정확히 확인

### > Terraform Init 오류
**권한 확인**
```bash
# gitlab-runner 사용자 권한 확인
sudo -u gitlab-runner terraform version
sudo -u gitlab-runner ls -la ~/.terraform.d/
```

**Provider 다운로드 문제**
```bash
# 네트워크 연결 확인
sudo -u gitlab-runner curl -I https://registry.terraform.io
```

### > Ansible 플레이북 실행 오류
**Inventory 파일 확인**
```bash
# inventory 파일 존재 및 권한 확인
ls -la inventory/
sudo -u gitlab-runner ansible-inventory -i inventory --list
```

**SSH 키 설정**
```bash
# gitlab-runner SSH 키 설정 확인
sudo -u gitlab-runner ls -la ~/.ssh/
sudo -u gitlab-runner ssh-keyscan target-host >> ~/.ssh/known_hosts
```

---

## 고급 설정

### 환경별 분리
```yaml
variables:
  TF_WORKDIR: "02-terraform"
  TF_VAR_environment: "${CI_COMMIT_BRANCH}"
  ANSIBLE_WORKDIR: "01-ansible"
```

### 승인 프로세스 강화
```yaml
tf:apply:
  # ... 기존 설정
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"'
      when: manual
```

### 병렬 실행 방지
```yaml
tf:apply:
  # ... 기존 설정
  resource_group: terraform

ansible:deploy:
  # ... 기존 설정
  resource_group: ansible
```

### 조건부 Include (선택사항)
```yaml
# /.gitlab-ci.yml - 고급 include 예시
include:
  - local: '03-GitLab/Runners/terraform.ci.yml'
    rules:
      - changes:
          - "02-terraform/**/*"
  - local: '03-GitLab/Runners/ansible.ci.yml'
    rules:
      - changes:
          - "01-ansible/**/*"
```

---

이제 Terraform과 Ansible CI 파이프라인이 분리되어 구성되었습니다. 각 컴포넌트의 변경 시 해당 파이프라인만 실행되어 효율적이고 안전한 인프라 관리가 가능합니다.
