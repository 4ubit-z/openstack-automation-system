# Terraform CI/CD 파이프라인 운영 매뉴얼

**목표**: GitLab CI/CD + Terraform으로 브랜치 기반 자동화 구축  
**전략**: dev → plan(자동) / main → apply(수동) / main → destroy(수동, 이중안전장치)

---

## 디렉터리 구조 (권장)

```
repo-root/
├─ terraform/                 # Terraform 코드
├─ gitlab-ci/
│  └─ terraform.ci.yml        # CI 파이프라인 정의
└─ .gitlab-ci.yml             # 루트 include
```

## 러너/인증 체크리스트

### 필수 확인사항
- Runner Online
- Run untagged jobs 허용 (꺼져있으면 잡에 tags 추가)
- OpenStack 인증 파일 배치 완료

### OpenStack 인증 파일(`clouds.yaml`) 배치

Terraform이 러너에서 OpenStack에 붙으려면 러너 계정 홈에 `clouds.yaml`이 있어야 합니다.

**경로 (필수)**
- **러너 계정 기준**: `~gitlab-runner/.config/openstack/clouds.yaml`
- **퍼미션**: `600`

** 러너 서버에 직접 복사 (현재 환경에 가장 간단)**
```bash
# (러너가 돌아가는 서버에서 실행)
sudo mkdir -p ~gitlab-runner/.config/openstack

# stack 계정에 있는 clouds.yaml을 러너 홈으로 복사
sudo cp ~stack/.config/openstack/clouds.yaml ~gitlab-runner/.config/openstack/clouds.yaml

# 소유권/권한 정리
sudo chown -R gitlab-runner:gitlab-runner ~gitlab-runner/.config/openstack
sudo chmod 600 ~gitlab-runner/.config/openstack/clouds.yaml

# 확인(러너 계정으로 HOME 기준 확인)
sudo -u gitlab-runner bash -lc 'ls -l ~/.config/openstack && sed -n "1,40p" ~/.config/openstack/clouds.yaml'
```

**중요**: `clouds.yaml` 안의 cloud 이름(예: `devstack`)과 CI에서 쓰는 `OS_CLOUD` 값이 **일치**해야 함

---

## CI 파일 구성

### 루트 .gitlab-ci.yml
```yaml
# 루트는 include만: 파이프라인 정의는 gitlab-ci/terraform.ci.yml에 둠
include:
  - local: 'gitlab-ci/terraform.ci.yml'
```

### gitlab-ci/terraform.ci.yml
```yaml
# stages 정의: plan → apply → destroy
stages: [plan, apply, destroy]

variables:
  TF_WORKDIR: "terraform"
  TF_IN_AUTOMATION: "1"

# 공통 준비 절차: OpenStack 인증 & Terraform init
.tf_setup: &tf_setup
  - export OS_CLIENT_CONFIG_FILE="$HOME/.config/openstack/clouds.yaml"  # 러너 계정 홈 기준(권한 600)
  - export OS_CLOUD="devstack"                                          # clouds.yaml의 cloud 이름
  - cd "$TF_WORKDIR"
  - terraform -version
  - terraform init -input=false -lock-timeout=60s

# ─────────────────────────────────────────────
# dev 브랜치: 변경사항 확인(plan) 자동 실행
tf:plan:
  stage: plan
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'          # dev push 시 자동 트리거
  before_script:
    - *tf_setup
  script: |
    terraform fmt -check
    terraform validate

    # detailed-exitcode: 0(변경없음)/1(오류)/2(변경있음)
    set +e
    terraform plan -no-color -input=false -detailed-exitcode -out=tfplan | tee plan.txt
    TF_EXIT=$?
    set -e

    if [ "$TF_EXIT" = "1" ]; then
      echo "terraform plan error"; exit 1
    elif [ "$TF_EXIT" = "0" ]; then
      echo "No changes"; exit 0
    else
      echo "Changes detected (exit=2). See plan.txt"
    fi
  artifacts:
    paths:
      - "terraform/plan.txt"     # 검토용
    expire_in: 1 day

# ─────────────────────────────────────────────
# main 브랜치: 실제 적용(apply) — 수동 실행
tf:apply:
  stage: apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual                      # 수동 버튼(안전)
  allow_failure: false
  before_script:
    - *tf_setup
  script: |
    # main에서도 변경차이 재확인(아티팩트 공유 경로 다를 수 있어 plan을 재생성)
    set +e
    terraform plan -no-color -input=false -detailed-exitcode -out=tfplan | tee plan.txt
    TF_EXIT=$?
    set -e

    if [ "$TF_EXIT" = "1" ]; then
      echo "terraform plan error"; exit 1
    elif [ "$TF_EXIT" = "0" ]; then
      echo "No changes. Skip apply."; exit 0
    else
      echo "Applying detected changes…"
      terraform apply -auto-approve tfplan || terraform apply -auto-approve
    fi
  artifacts:
    paths:
      - "terraform/plan.txt"
    expire_in: 1 day

# ─────────────────────────────────────────────
# main 브랜치: 파괴(destroy) — 수동 실행 + 환경변수 안전장치
tf:destroy:
  stage: destroy
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  allow_failure: false
  before_script:
    - *tf_setup
  script: |
    # 이중 안전장치: CI/CD Variables 에 DESTROY_OK=yes 설정 필요
    if [ "${DESTROY_OK:-no}" != "yes" ]; then
      echo "Set CI/CD variable DESTROY_OK=yes to enable destroy"; exit 1
    fi

    echo "!!! Terraform DESTROY starts in 10 seconds !!!"
    sleep 10
    terraform destroy -auto-approve -lock-timeout=60s
```


---

## Git 사용법

### 0) 현재 브랜치/상태 확인
```bash
git status                                        # 변경 파일, 스테이징 여부 확인
git branch -vv                                    # 로컬 브랜치와 원격 추적 상태 확인
git log --oneline --graph --decorate -n 10       # 최근 커밋 그래프
```

### 1) 브랜치 이동/생성
```bash
git switch dev                    # 권장 문법(= git checkout dev)
# 또는
git checkout dev

git switch -c feature/xxx         # 새 브랜치 생성 후 이동(= git checkout -b feature/xxx)
```

### 2) 변경사항 커밋 & 푸시
```bash
git add .                                           # 모든 변경 스테이징
git commit -m "feat(ci): add apply & destroy"       # 메시지는 꾸준한 형식 권장
git push origin dev                                 # 원격 dev에 푸시 → dev 파이프라인(plan) 자동 실행
```

### 3) 원격과 동기화 (pull)
```bash
# 안전한 습관: merge 전략 명시
git pull origin dev --no-rebase       # merge commit 생성(기록 보존)
# 또는
git pull origin dev --rebase          # 히스토리 깔끔 (충돌 처리 숙련 필요)
```

### 4) 분기(diverged) 경고/거절 해결
```bash
# 로컬 main 과 origin/main 이 서로 다른 커밋을 가졌을 때
git pull origin main --no-rebase      # 먼저 합치고
git merge dev                         # dev 내용 반영(필요시)
git push origin main                  # 그 다음 push
```

### 5) 임시 보관(stash)
```bash
git stash                             # 작업 보관(스테이징 안 된 변경 포함)
git pull --rebase origin dev          # 깨끗한 상태에서 동기화
git stash pop                         # 보관한 변경 복구(충돌 나면 해결 후 add/commit)
```

### 6) 브랜치 보호 & 머지 전략
- **main**: Protected Branch, 직접 push 금지 → MR(merge request)만 허용
- **dev**: 작업용, 직접 push 허용(또는 MR)

**머지 권장 루틴(웹)**:
1. Merge Requests → New merge request
2. Source: dev, Target: main
3. Create merge request → 코드/plan.txt 검토 → Merge 클릭
4. main 파이프라인에서 tf:apply 버튼 수동 실행

---

## 파이프라인 운영 루틴

### A) 개발/테스트 (개발자가 자주 수행)
```bash
git switch dev
# 코드/CI 수정
git add .
git commit -m "fix(terraform): adjust security-group rules"
git push origin dev            # → GitLab: dev 파이프라인에서 tf:plan 자동 실행
```
> GitLab → Pipelines → dev → plan.txt 아티팩트 열어 변경사항 검토

### B) 배포 (유지관리자/승인자)
1. GitLab 웹에서 MR(dev → main) 생성 → 리뷰/승인 → Merge
2. GitLab Pipelines → main 에서 tf:apply Play 클릭(수동)
3. 로그에서 리소스 생성/갱신 확인

### C) 종료/철거 (필요 시)
1. GitLab Settings → CI/CD → Variables: `DESTROY_OK=yes` 지정
2. GitLab Pipelines → main 에서 tf:destroy Play 클릭(수동)
3. 로그에서 모든 리소스 제거 확인

---

## 트러블슈팅

### > Runner 연결 문제
```bash
# GitLab Runner 상태 확인
sudo gitlab-runner status
sudo gitlab-runner list

# Runner 재등록
sudo gitlab-runner register
```

### > OpenStack 인증 오류
```bash
# clouds.yaml 파일 권한 확인
ls -la ~gitlab-runner/.config/openstack/clouds.yaml
sudo chmod 600 ~gitlab-runner/.config/openstack/clouds.yaml

# 인증 테스트
sudo -u gitlab-runner openstack --os-cloud devstack server list
```

### > Terraform State Lock 오류
```bash
# Lock 해제 (주의: 다른 작업이 없을 때만)
cd terraform
terraform force-unlock <LOCK_ID>
```

### > Plan 아티팩트 확인 안 됨
- GitLab → Pipelines → 해당 Job → Browse artifacts
- plan.txt 파일 다운로드하여 변경사항 검토

### > Destroy 안전장치 오류
- GitLab → Settings → CI/CD → Variables
- `DESTROY_OK` 변수를 `yes` 값으로 설정

---

이제 Terraform CI/CD 파이프라인이 구성되었습니다. dev 브랜치에서 안전하게 테스트하고, main 브랜치에서 수동 승인을 통해 운영 인프라를 관리할 수 있습니다.
