# Phase 4-4: Terraform 자동 실행 CI (GitLab Runner/Shell 기준)

이 문서는 dev → plan, main → apply(수동 승인) 흐름으로 Terraform을 자동 실행하는 상세 가이드입니다.
환경은 Shell Executor Runner(mydevstack)이며, OpenStack 인증은 clouds.yaml을 사용합니다.

## 0) 전제 조건 및 사전 준비

Runner 동작 확인이 완료되어야 합니다.

### Git 저장소 구조 예시

```
repo-root/
 ├─ terraform/
 │   ├─ main.tf
 │   ├─ variables.tf
 │   ├─ outputs.tf
 │   └─ backend.tf        # (선택) 원격 상태 사용 시
 └─ .gitlab-ci.yml        # 이번 단계에서 작성
```

### GitLab 설정

1. **Protected Branch 설정**
   - GitLab 프로젝트 Settings → Repository → Protected branches에서 main 보호를 권장합니다.

2. **CI/CD 변수 등록**
   - GitLab 프로젝트 Settings → CI/CD → Variables에 아래 항목을 등록합니다:
     - `OS_CLOUD = default` (clouds.yaml 내 cloud 이름)
     - `OPENSTACK_CLOUDS_YAML = clouds.yaml 전체 내용` (Masked, Protected 권장)
       → 파일을 변수에서 사용해서 Runner에 임시 파일로 생성합니다.
     - (선택) `TF_LOG = INFO` (디버깅 시)
     - (선택) `TF_VAR_...` 형태로 Terraform 변수 등록

**주의**: clouds.yaml은 절대 저장소에 커밋하지 말고, CI 변수로 보관합니다.

## 1) 핵심 전략

### Stage 분리
- init → plan → apply

### 브랜치 규칙
- **dev**: init, plan 자동 실행
- **main**: init, plan + apply는 manual (승인 필요)

### 상태 관리
- 처음에는 로컬 상태(terraform/ 아래 .terraform/ & terraform.tfstate)로 시작
- 이후 운영 단계에서 S3/Swift 등 원격 backend로 전환을 권장

### 보안
- 인증 파일은 CI 변수 → Job 시작 시 임시 파일로 쓰고, 끝나면 삭제

### 캐시
- .terraform 플러그인/모듈 캐시로 속도 향상

## 2) .gitlab-ci.yml 완성 예시

Runner가 untagged jobs 허용이면 tags: 생략 (지금 그렇게 구성되어 있음)

```yaml
stages:
  - init
  - plan
  - apply

# 공통 설정
.default_template:
  image: ""              # Shell Executor라서 미사용
  before_script:
    # 1) Terraform 설치 확인 (있다면 스킵)
    - |
      if ! command -v terraform >/dev/null 2>&1; then
        echo "[INFO] Installing Terraform..."
        sudo apt-get update -y
        sudo apt-get install -y wget unzip
        TF_VERSION="1.6.6"
        wget -q https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip
        unzip -o terraform_${TF_VERSION}_linux_amd64.zip
        sudo mv terraform /usr/local/bin/terraform
        terraform -version
      else
        echo "[INFO] Terraform already installed:"
        terraform -version
      fi
    # 2) OpenStack 인증 파일 생성
    - mkdir -p ~/.config/openstack
    - echo "$OPENSTACK_CLOUDS_YAML" > ~/.config/openstack/clouds.yaml
    - chmod 600 ~/.config/openstack/clouds.yaml
    # 3) 작업 디렉터리 이동
    - cd terraform
  after_script:
    # 민감 파일 정리
    - shred -u ~/.config/openstack/clouds.yaml || true

# 캐시 (플러그인/모듈)
.cache_template:
  cache:
    key: "terraform-cache"
    paths:
      - terraform/.terraform/
    policy: pull-push

init:
  stage: init
  extends:
    - .default_template
    - .cache_template
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
    - if: '$CI_COMMIT_BRANCH == "main"'
  script:
    - terraform init -input=false
  artifacts:
    paths:
      - terraform/.terraform/
    expire_in: 2h

plan:
  stage: plan
  extends:
    - .default_template
    - .cache_template
  needs: ["init"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
      when: on_success
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: on_success
  script:
    - terraform fmt -check
    - terraform validate
    - terraform plan -input=false -out=tfplan
  artifacts:
    name: "tfplan-$CI_COMMIT_SHORT_SHA"
    paths:
      - terraform/tfplan
      - terraform/.terraform/
    expire_in: 1 day
  allow_failure: false

apply:
  stage: apply
  extends:
    - .default_template
    - .cache_template
  needs: ["plan"]
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual         # 수동 승인
      allow_failure: false
    - when: never          # 기타 브랜치 차단
  script:
    - ls -l
    - terraform show tfplan || true
    - terraform apply -input=false -auto-approve tfplan
```

### 주요 포인트

- `OPENSTACK_CLOUDS_YAML` 변수 내용을 `~/.config/openstack/clouds.yaml`로 저장 → `OS_CLOUD=default` 이름 사용
- plan 단계에서 tfplan을 Artifacts로 보관 → apply에서 그대로 사용
- apply는 main에서만 수동 승인(manual)

## 3) backend 설정 (선택사항, 운영 환경 권장)

원격 상태를 사용하려면 `terraform/backend.tf` 등을 만들어 관리합니다.

### Swift 예시

```hcl
terraform {
  backend "swift" {
    container = "tfstate"
    archive_container = "tfstate-archives"
    tenant_name = "admin"   # 또는 프로젝트명
    user_name   = "admin"
    password    = var.swift_password
    auth_url    = "http://<keystone-url>:5000/v3"
    region_name = "RegionOne"
  }
}
```

- 자격증명은 clouds.yaml을 그대로 사용하는 플러그인/환경설정 또는 backend 변수로 주입
- backend 전환 시 기존 로컬 state를 `terraform init -migrate-state`로 마이그레이션

## 4) 브랜치 정책 및 보호

### 브랜치 별 동작

- **dev**: plan만 자동
- **main**: merge 후 plan + 수동 apply

### 권장 설정

- GitLab Protected Branch로 main을 보호하고, Allowed to merge와 Allowed to push 권한을 제한
- apply Job은 기본적으로 Protected Runner에서만 실행되게 하는 것을 권장

## 5) 수동 apply 승인 방법

1. Build → Pipelines → 해당 파이프라인 진입
2. apply Job 오른쪽의 Play ▶ 버튼 클릭 → 승인 사용자/주석 남기기 가능

## 6) 로컬에서 재현하기 (디버깅 팁)

Runner와 동일하게 시뮬레이션하려면:

```bash
export OS_CLOUD=default
mkdir -p ~/.config/openstack && chmod 700 ~/.config/openstack
echo "$OPENSTACK_CLOUDS_YAML" > ~/.config/openstack/clouds.yaml
cd terraform
terraform init -input=false
terraform plan -input=false -out=tfplan
terraform apply -input=false -auto-approve tfplan
```
