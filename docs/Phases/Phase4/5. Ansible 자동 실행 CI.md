# Terraform + Ansible 자동화 가이드

## 개요

Terraform으로 VM 생성 후 Ansible 플레이북을 자동으로 적용하는 파이프라인을 구성함. 기존 inventory 파일 방식에서 발생하던 IP 매칭 문제를 해결하기 위해 콤마 인벤토리 방식으로 변경함.

**주요 변경점:**
- 기존: `inventory.ini` 파일 → 새로운: `-i "IP,"` 콤마 인벤토리
- 플레이북: `hosts: web` → `hosts: all`로 통일
- IP 동기화 문제 완전 해결

## SSH 키 관리

### Base64 인코딩 생성

```bash
base64 -w 0 ~/.ssh/ansible_key > ansible_key.b64
```

- `-w 0` 옵션으로 줄바꿈 없이 한 줄로 출력
- GitLab CI 변수 등록용

### GitLab CI/CD 변수 등록

- **Key**: `ANSIBLE_PRIVATE_KEY_B64`
- **Value**: Base64 인코딩된 키 전체 문자열
- **Masked**: 체크 필수
- **Protected**: 필요에 따라 설정

### CI에서 SSH 키 복원

```bash
mkdir -p ~/.ssh
echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/ansible_key
chmod 600 ~/.ssh/ansible_key
```

## 프로젝트 구조

```
repo-root/
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf          # floating_ip 출력 정의
│   └── ...
├── ansible/
│   ├── hosts-fix.yml
│   ├── nginx.yml
│   └── jenkins.yml
├── gitlab_ci/
│   └── terraform.ci.yml
└── .gitlab-ci.yml
```

## Ansible 플레이북

### hosts-fix.yml - 호스트명 및 DNS 설정

```yaml
---
- name: Fix /etc/hosts to match hostname and set DNS
  hosts: all
  become: true
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Get current hostname
      command: hostname
      register: current_hostname
      changed_when: false

    - name: Add hostname to 127.0.0.1 line if not present
      lineinfile:
        path: /etc/hosts
        regexp: '^127\.0\.0\.1'
        line: "127.0.0.1 localhost {{ current_hostname.stdout }}"
        state: present
        backup: yes

    - name: Remove broken resolv.conf symlink if exists
      file:
        path: /etc/resolv.conf
        state: absent

    - name: Ensure resolv.conf file exists (fresh file)
      copy:
        dest: /etc/resolv.conf
        content: ""
        mode: '0644'

    - name: Ensure Google DNS is first in resolv.conf
      lineinfile:
        path: /etc/resolv.conf
        line: "nameserver 8.8.8.8"
        insertbefore: BOF
        state: present
        backup: yes
```

### nginx.yml - Nginx 설치 및 시작

```yaml
---
- name: Install and start Nginx on target server
  hosts: all
  become: yes
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Update apt cache
      apt: { update_cache: yes }

    - name: Upgrade packages
      apt: { upgrade: yes }

    - name: Install Nginx
      apt: { name: nginx, state: present }

    - name: Start and enable Nginx
      service: { name: nginx, state: started, enabled: yes }
```

### jenkins.yml - Jenkins 설치

```yaml
---
- name: Install Java 17 and Jenkins
  hosts: all
  become: yes
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Install Java 17
      apt: { name: openjdk-17-jdk, state: present, update_cache: yes }

    - name: Download Jenkins GPG key
      ansible.builtin.get_url:
        url: https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
        dest: /usr/share/keyrings/jenkins-keyring.asc
        mode: '0644'

    - name: Add Jenkins repository
      ansible.builtin.apt_repository:
        repo: "deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/"
        filename: jenkins
        state: present

    - name: Install Jenkins
      apt: { name: jenkins, state: present, update_cache: yes }

    - name: Enable & start Jenkins
      service: { name: jenkins, state: started, enabled: yes }
```

## GitLab CI 파이프라인

### terraform.ci.yml 전체 구조

```yaml
# stages 정의: plan → apply → config → destroy
stages: [plan, apply, config, destroy]

variables:
  TF_WORKDIR: "terraform"
  TF_IN_AUTOMATION: "1"
  TF_INPUT: "false"

# ─────────────────────────────────────────────
# 공통 준비 절차: OpenStack 인증 & Terraform init
.tf_setup: &tf_setup
  - export OS_CLIENT_CONFIG_FILE="$HOME/.config/openstack/clouds.yaml"  # 러너 계정 홈 기준(권한 600)
  - export OS_CLOUD="devstack"                                          # clouds.yaml의 cloud 이름
  - cd "$TF_WORKDIR"
  - terraform -version
  - terraform init -input=false -lock-timeout=60s

# Ansible 준비(파이썬/키 복원)
.ansible_setup: &ansible_setup
  - sudo apt-get update -y
  - sudo apt-get install -y jq python3 python3-pip sshpass
  - pip3 install --user ansible
  - mkdir -p ~/.ssh
  - echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/ansible_key
  - chmod 600 ~/.ssh/ansible_key
  - export ANSIBLE_HOST_KEY_CHECKING=False
  - export PATH="$HOME/.local/bin:$PATH"

# ─────────────────────────────────────────────
# dev 브랜치: 변경사항 확인(plan) 자동 실행
tf:plan:
  stage: plan
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
  before_script:
    - *tf_setup
  script: |
    terraform fmt -check
    terraform validate

    # detailed-exitcode: 0(변경없음)/1(오류)/2(변경있음)
    set +e
    terraform plan -no-color -input=false -detailed-exitcode -out=tfplan | tee plan.txt
    TF_EXIT=$?
    set -e

    if [ "$TF_EXIT" = "1" ]; then
      echo "terraform plan error"; exit 1
    elif [ "$TF_EXIT" = "0" ]; then
      echo "No changes"; exit 0
    else
      echo "Changes detected (exit=2). See plan.txt"
    fi
  artifacts:
    paths:
      - "terraform/plan.txt"
      - "terraform/tfplan"
    expire_in: 1 day

# ─────────────────────────────────────────────
# main 브랜치: 실제 적용(apply) — 수동 실행
tf:apply:
  stage: apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  allow_failure: false
  before_script:
    - *tf_setup
  script: |
    # main에서도 변경차이 재확인(아티팩트 공유 경로 다를 수 있어 plan을 재생성)
    set +e
    terraform plan -no-color -input=false -detailed-exitcode -out=tfplan | tee plan.txt
    TF_EXIT=$?
    set -e

    if [ "$TF_EXIT" = "1" ]; then
      echo "terraform plan error"; exit 1
    elif [ "$TF_EXIT" = "0" ]; then
      echo "No changes. Skip apply."; exit 0
    else
      echo "Applying detected changes…"
      terraform apply -auto-approve tfplan || terraform apply -auto-approve
    fi

    # ── Output에서 배포 대상 IP 추출(프로젝트에 맞춰 키명을 사용)
    # 우선순위: floating_ip > vm_ip > public_ip
    TARGET_IP="$(terraform output -raw floating_ip 2>/dev/null || true)"
    [ -z "$TARGET_IP" ] && TARGET_IP="$(terraform output -raw vm_ip 2>/dev/null || true)"
    [ -z "$TARGET_IP" ] && TARGET_IP="$(terraform output -raw public_ip 2>/dev/null || true)"
    if [ -z "$TARGET_IP" ]; then
      echo "No IP output found from Terraform (define output 'floating_ip' or 'vm_ip' or 'public_ip')."
      exit 1
    fi
    echo "TARGET_IP=$TARGET_IP" > target_ip.env
    cat target_ip.env
  artifacts:
    paths:
      - "terraform/plan.txt"
    reports:
      dotenv: target_ip.env     # → 다음 스테이지에서 env로 사용
    expire_in: 1 day

# ─────────────────────────────────────────────
# main 브랜치: Ansible 구성(config) — apply 성공 시 자동
tf:ansible:
  stage: config
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  needs: ["tf:apply"]
  before_script:
    - *ansible_setup
  script: |
    # TARGET_IP는 tf:apply 아티팩트(.env)에서 주입됨
    : "${TARGET_IP:?TARGET_IP is required}"
    echo "Target host: $TARGET_IP"

    # 호스트키 편의 등록(초기 접속 마찰 감소)
    ssh-keyscan -H "$TARGET_IP" >> ~/.ssh/known_hosts || true

    # 연결 확인
    ansible -i "${TARGET_IP}," -m ping all -u ubuntu --private-key ~/.ssh/ansible_key

    # 1) /etc/hosts + DNS(nameserver) 일시 적용(깨진 symlink 처리 포함)
    ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key \
      --ssh-extra-args="-o StrictHostKeyChecking=no" ansible/hosts-fix.yml

    # 2) Nginx 설치/기동
    ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key \
      --ssh-extra-args="-o StrictHostKeyChecking=no" ansible/nginx.yml

    # 3) Jenkins 설치/기동
    ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key \
      --ssh-extra-args="-o StrictHostKeyChecking=no" ansible/jenkins.yml

# (선택) 재적용/문제대응용 수동 Ansible Job
tf:ansible:manual:
  stage: config
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  allow_failure: true
  needs: ["tf:apply"]
  before_script:
    - *ansible_setup
  script: |
    : "${TARGET_IP:?TARGET_IP is required}"
    ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key \
      --ssh-extra-args="-o StrictHostKeyChecking=no" ansible/nginx.yml

# ─────────────────────────────────────────────
# main 브랜치: 파괴(destroy) — 수동 실행 + 환경변수 안전장치
tf:destroy:
  stage: destroy
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  allow_failure: false
  before_script:
    - *tf_setup
  script: |
    # 이중 안전장치: CI/CD Variables 에 DESTROY_OK=yes 설정 필요
    if [ "${DESTROY_OK:-no}" != "yes" ]; then
      echo "Set CI/CD variable DESTROY_OK=yes to enable destroy"; exit 1
    fi

    echo "!!! Terraform DESTROY starts in 10 seconds !!!"
    sleep 10
    terraform destroy -auto-approve -lock-timeout=60s
```

## 인벤토리 방식 비교

### 기존 방식 (inventory 파일)
- `inventory.ini` 파일에 그룹별 서버 정의
- 플레이북에서 `hosts: web` 등 그룹 지정
- **문제점**: CI/CD에서 인벤토리 파일 갱신 누락 시 IP 불일치 발생

### 현재 방식 (콤마 인벤토리)
- Terraform output에서 IP 직접 추출
- `-i "${TARGET_IP},"` 방식으로 단일 서버 지정
- 플레이북은 `hosts: all`로 통일
- **장점**: 인벤토리 파일 불필요, 동기화 문제 완전 해결

## 실행 흐름

1. **Plan 단계**: Terraform 계획 생성 및 검증
2. **Apply 단계**: VM 생성 후 IP 추출하여 환경변수로 전달
3. **Config 단계**: 추출된 IP로 Ansible 플레이북 자동 실행
   - hosts-fix.yml: 호스트명 및 DNS 설정
   - nginx.yml: Nginx 설치 및 구동
   - jenkins.yml: Jenkins 설치 및 구동
4. **Manual Config**: 필요 시 수동으로 특정 플레이북만 재실행 가능

## 핵심 특징

- **완전 자동화**: Terraform apply 후 Ansible이 자동 실행됨
- **IP 동기화 문제 해결**: 콤마 인벤토리로 실시간 IP 전달
- **재실행 가능**: 수동 Job으로 필요시 재설정 가능
- **보안**: SSH 키 Base64 인코딩으로 안전하게 관리
