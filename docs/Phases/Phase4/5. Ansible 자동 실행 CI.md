Phase 4-5: Terraform 적용 직후 Ansible 자동 구성
0) 개요

이번 단계에서는 Terraform이 생성한 VM에 Ansible 플레이북을 자동 적용합니다.

기존에는 Ansible이 inventory 파일(inventory.ini)을 사용했으나, CI 파이프라인에서 IP 매칭 실패 문제가 반복되었습니다.

따라서, 이번 단계부터는 콤마 인벤토리 방식(-i "IP,")으로 단일 서버를 직접 지정하고, 플레이북은 hosts: all로 통일합니다.

1) SSH 키 관리 (Base64 인코딩)
1.1 SSH 키 → Base64 인코딩
base64 -w 0 ~/.ssh/ansible_key > ansible_key.b64


-w 0: 줄바꿈 없이 한 줄 출력 (GitLab 변수 등록에 필수)

결과 파일 ansible_key.b64의 문자열을 복사 → GitLab 변수 등록

1.2 GitLab → CI/CD 변수 등록

Key: ANSIBLE_PRIVATE_KEY_B64

Value: (Base64 문자열 전체)

Masked: ✅

Protected: 필요 시 선택

1.3 CI에서 복원 (before_script)
mkdir -p ~/.ssh
echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/ansible_key
chmod 600 ~/.ssh/ansible_key

2) 디렉터리 구조 (Phase 4-5 기준)
repo-root/
├─ terraform/                # Terraform 코드
│  ├─ main.tf
│  ├─ variables.tf
│  ├─ outputs.tf             # floating_ip 등 출력
│  └─ ...
├─ ansible/                  # Ansible 플레이북
│  ├─ hosts-fix.yml
│  ├─ nginx.yml
│  └─ jenkins.yml
└─ .gitlab-ci.yml            # GitLab CI 파이프라인 정의

3) Ansible 플레이북 (최종본)
3.1 ansible/hosts-fix.yml
---
- name: Fix /etc/hosts to match hostname and set DNS
  hosts: all
  become: true
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Get current hostname
      command: hostname
      register: current_hostname
      changed_when: false

    - name: Add hostname to 127.0.0.1 line if not present
      lineinfile:
        path: /etc/hosts
        regexp: '^127\.0\.0\.1'
        line: "127.0.0.1 localhost {{ current_hostname.stdout }}"
        state: present
        backup: yes

    # ── resolv.conf: 깨진 symlink 제거 → 새 파일 생성 → nameserver 추가
    - name: Remove broken resolv.conf symlink if exists
      file:
        path: /etc/resolv.conf
        state: absent

    - name: Ensure resolv.conf file exists (fresh file)
      copy:
        dest: /etc/resolv.conf
        content: ""
        mode: '0644'

    - name: Ensure Google DNS is first in resolv.conf
      lineinfile:
        path: /etc/resolv.conf
        line: "nameserver 8.8.8.8"
        insertbefore: BOF
        state: present
        backup: yes

3.2 ansible/nginx.yml
---
- name: Install and start Nginx on target server
  hosts: all
  become: yes
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Update apt cache
      apt: { update_cache: yes }

    - name: Upgrade packages
      apt: { upgrade: yes }

    - name: Install Nginx
      apt: { name: nginx, state: present }

    - name: Start and enable Nginx
      service: { name: nginx, state: started, enabled: yes }

3.3 ansible/jenkins.yml
---
- name: Install Java 17 and Jenkins
  hosts: all
  become: yes
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Install Java 17
      apt: { name: openjdk-17-jdk, state: present, update_cache: yes }

    - name: Download Jenkins GPG key
      ansible.builtin.get_url:
        url: https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
        dest: /usr/share/keyrings/jenkins-keyring.asc
        mode: '0644'

    - name: Add Jenkins repository
      ansible.builtin.apt_repository:
        repo: "deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/"
        filename: jenkins
        state: present

    - name: Install Jenkins
      apt: { name: jenkins, state: present, update_cache: yes }

    - name: Enable & start Jenkins
      service: { name: jenkins, state: started, enabled: yes }

4) GitLab CI 통합
4.1 기존 Terraform CI (Phase 4-4)

plan → apply → destroy 구조로 이미 설정됨.

4.2 이번 단계에서 추가/변경

config stage 추가 → tf:ansible 자동 실행

Base64 SSH 키 복원 로직 추가 (before_script)

Terraform Output(IP) → ansible-playbook 실행 연결

4.3 최종 .gitlab-ci.yml 예시
stages: [plan, apply, config, destroy]

variables:
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

before_script:
  - sudo apt-get update -y
  - sudo apt-get install -y jq python3 python3-pip sshpass
  - pip3 install --user ansible
  - mkdir -p ~/.ssh
  - echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/ansible_key
  - chmod 600 ~/.ssh/ansible_key
  - export ANSIBLE_HOST_KEY_CHECKING=False
  - export PATH="$HOME/.local/bin:$PATH"

tf:plan:
  stage: plan
  script:
    - terraform -chdir=terraform init -upgrade
    - terraform -chdir=terraform plan -out=tfplan
    - terraform -chdir=terraform show -no-color tfplan > terraform/plan.txt
  artifacts:
    paths: [terraform/tfplan, terraform/plan.txt]

tf:apply:
  stage: apply
  when: manual
  script:
    - terraform -chdir=terraform apply -auto-approve tfplan
    - |
      TARGET_IP="$(terraform -chdir=terraform output -raw floating_ip 2>/dev/null || true)"
      [ -z "$TARGET_IP" ] && TARGET_IP="$(terraform -chdir=terraform output -raw vm_ip 2>/dev/null || true)"
      [ -z "$TARGET_IP" ] && TARGET_IP="$(terraform -chdir=terraform output -raw public_ip 2>/dev/null || true)"
      [ -z "$TARGET_IP" ] && { echo "No IP output"; exit 1; }
      echo "TARGET_IP=$TARGET_IP" > target_ip.env
  artifacts:
    reports: { dotenv: target_ip.env }

tf:ansible:
  stage: config
  needs: ["tf:apply"]
  script:
    - source target_ip.env
    - ssh-keyscan -H "$TARGET_IP" >> ~/.ssh/known_hosts || true
    - ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key ansible/hosts-fix.yml
    - ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key ansible/nginx.yml
    - ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key ansible/jenkins.yml

tf:ansible:manual:
  stage: config
  when: manual
  allow_failure: true
  needs: ["tf:apply"]
  script:
    - source target_ip.env
    - ansible-playbook -i "${TARGET_IP}," -u ubuntu --private-key ~/.ssh/ansible_key ansible/nginx.yml

5) 왜 인벤토리를 안 쓰는가?
기존 (inventory 방식)

인벤토리 파일(inventory.ini)에 web, db, jenkins 그룹 정의

플레이북은 hosts: web 실행

CI/CD에서는 인벤토리 갱신 누락 시 IP mismatch 발생 → 실패

지금 (콤마 인벤토리 방식)

Terraform Output(IP) → CI에서 -i "${TARGET_IP}," 전달

플레이북은 hosts: all 실행

인벤토리 파일 필요 없음 → 동기화 문제 제거

6) 동작 흐름

수동: tf:apply 실행 → Terraform이 VM 생성 → IP 출력

자동: tf:ansible 실행 → Ansible 플레이북 자동 실행

(선택) 수동: tf:ansible:manual 실행 시 ansible 재적용 가능

7) 결론

현재 단계(단일 VM, 실습 환경): 콤마 인벤토리 방식이 가장 단순하고 안정적

확장 단계(다중 VM, 역할별 관리): inventory 파일/동적 인벤토리로 되돌아갈 계획

보안/편의: SSH 키는 반드시 Base64 인코딩 후 GitLab 변수로 관리 → 파이프라인에서 자동 복원
