# Terraform + Ansible 자동화 가이드

## 개요

Terraform으로 VM 생성 후 Ansible 플레이북을 자동으로 적용하는 파이프라인을 구성함. 기존 inventory 파일 방식에서 발생하던 IP 매칭 문제를 해결하기 위해 콤마 인벤토리 방식으로 변경함.

**주요 변경점:**
- 기존: `inventory.ini` 파일 → 새로운: `-i "IP,"` 콤마 인벤토리
- 플레이북: `hosts: web` → `hosts: all`로 통일
- IP 동기화 문제 완전 해결

## SSH 키 관리

### Base64 인코딩 생성

```bash
base64 -w 0 ~/.ssh/ansible_key > ansible_key.b64
```

- `-w 0` 옵션으로 줄바꿈 없이 한 줄로 출력
- GitLab CI 변수 등록용

### GitLab CI/CD 변수 등록

- **Key**: `ANSIBLE_PRIVATE_KEY_B64`
- **Value**: Base64 인코딩된 키 전체 문자열
- **Masked**: 체크 필수
- **Protected**: 필요에 따라 설정

### CI에서 SSH 키 복원

```bash
mkdir -p ~/.ssh
echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/ansible_key
chmod 600 ~/.ssh/ansible_key
```

## 프로젝트 구조

```
repo-root/
├── terraform/
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf          # floating_ip 출력 정의
│   └── ...
├── ansible/
│   ├── hosts-fix.yml
│   ├── nginx.yml
│   └── jenkins.yml
├── gitlab_ci/
│   └── terraform.ci.yml
└── .gitlab-ci.yml
```

## Ansible 플레이북

### hosts-fix.yml - 호스트명 및 DNS 설정

```yaml
---
- name: Fix /etc/hosts to match hostname and set DNS
  hosts: all
  become: true
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Get current hostname
      command: hostname
      register: current_hostname
      changed_when: false

    - name: Add hostname to 127.0.0.1 line if not present
      lineinfile:
        path: /etc/hosts
        regexp: '^127\.0\.0\.1'
        line: "127.0.0.1 localhost {{ current_hostname.stdout }}"
        state: present
        backup: yes

    - name: Remove broken resolv.conf symlink if exists
      file:
        path: /etc/resolv.conf
        state: absent

    - name: Ensure resolv.conf file exists (fresh file)
      copy:
        dest: /etc/resolv.conf
        content: ""
        mode: '0644'

    - name: Ensure Google DNS is first in resolv.conf
      lineinfile:
        path: /etc/resolv.conf
        line: "nameserver 8.8.8.8"
        insertbefore: BOF
        state: present
        backup: yes
```

### nginx.yml - Nginx 설치 및 시작

```yaml
---
- name: Install and start Nginx on target server
  hosts: all
  become: yes
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Update apt cache
      apt: { update_cache: yes }

    - name: Upgrade packages
      apt: { upgrade: yes }

    - name: Install Nginx
      apt: { name: nginx, state: present }

    - name: Start and enable Nginx
      service: { name: nginx, state: started, enabled: yes }
```

### jenkins.yml - Jenkins 설치

```yaml
---
- name: Install Java 17 and Jenkins
  hosts: all
  become: yes
  vars:
    ansible_user: ubuntu
    ansible_python_interpreter: /usr/bin/python3

  tasks:
    - name: Install Java 17
      apt: { name: openjdk-17-jdk, state: present, update_cache: yes }

    - name: Download Jenkins GPG key
      ansible.builtin.get_url:
        url: https://pkg.jenkins.io/debian-stable/jenkins.io-2023.key
        dest: /usr/share/keyrings/jenkins-keyring.asc
        mode: '0644'

    - name: Add Jenkins repository
      ansible.builtin.apt_repository:
        repo: "deb [signed-by=/usr/share/keyrings/jenkins-keyring.asc] https://pkg.jenkins.io/debian-stable binary/"
        filename: jenkins
        state: present

    - name: Install Jenkins
      apt: { name: jenkins, state: present, update_cache: yes }

    - name: Enable & start Jenkins
      service: { name: jenkins, state: started, enabled: yes }
```

## GitLab CI 파이프라인

### terraform.ci.yml 전체 구조

```yaml# ─────────────────────────────────────────────────────────
# 파이프라인 단계
stages: [plan, apply, configure, destroy]

# 공통 변수
variables:
  TF_WORKDIR: "terraform"        # Terraform 코드 디렉토리
  TF_IN_AUTOMATION: "1"
  ANSIBLE_DIR: "ansible-test"    # 너의 Ansible 폴더명 (원하면 변경)

# 공통 준비 단계(앵커)
.tf_setup: &tf_setup
  - export OS_CLIENT_CONFIG_FILE="$HOME/.config/openstack/clouds.yaml"
  - export OS_CLOUD="devstack"   # clouds.yaml의 cloud 이름
  - cd "$TF_WORKDIR"
  - terraform -version
  - terraform init -input=false -lock-timeout=60s

# ─────────────────────────────────────────────────────────
# DEV 브랜치: plan만 실행 (리뷰용)
tf:plan:
  stage: plan
  rules:
    - if: '$CI_COMMIT_BRANCH == "dev"'
  before_script:
    - *tf_setup
  script:
    - terraform fmt -check
    - terraform validate
    - |
      set +e
      terraform plan -no-color -input=false -detailed-exitcode -out=tfplan | tee plan.txt
      TF_EXIT=$?
      set -e
      if [ "$TF_EXIT" = "1" ]; then
        echo "terraform plan error"; exit 1
      elif [ "$TF_EXIT" = "0" ]; then
        echo "No changes"; exit 0
      else
        echo "Changes detected (exit 2). Review plan.txt."
      fi
  artifacts:
    paths:
      - "terraform/plan.txt"
    expire_in: 1 day

# ─────────────────────────────────────────────────────────
# MAIN 브랜치: plan 재확인 후 apply (수동 승인)
tf:apply:
  stage: apply
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  allow_failure: false
  before_script:
    - *tf_setup
  script:
    - |
      set +e
      terraform plan -no-color -input=false -detailed-exitcode -out=tfplan | tee plan.txt
      TF_EXIT=$?
      set -e

      if [ "$TF_EXIT" = "1" ]; then
        echo "terraform plan error"; exit 1
      elif [ "$TF_EXIT" = "0" ]; then
        echo "No changes. Skip apply."
        rm -f .changed || true
        exit 0
      else
        echo "Changes detected. Applying…"
        terraform apply -auto-approve tfplan || terraform apply -auto-approve
        echo "changes" > .changed
      fi
  artifacts:
    when: always
    paths:
      - "terraform/plan.txt"
      - "terraform/terraform.tfstate"
      - "terraform/terraform.tfstate.backup"
      - "terraform/.terraform.lock.hcl"
      - "terraform/.changed"       # 변경 플래그
    expire_in: 7 days

# ─────────────────────────────────────────────────────────
# MAIN 브랜치: apply 이후 Ansible (자동, 변경 있을 때만)
tf:ansible:
  stage: configure
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  needs: ["tf:apply"]            # apply 성공 후 이어짐
  dependencies: ["tf:apply"]     # apply 아티팩트(state/changed) 수신
  before_script:
    - *tf_setup                  # 현재 작업디렉토리는 $TF_WORKDIR(=terraform)
    - export PATH="$HOME/.local/bin:$PATH"
    - python3 -m pip install --user --upgrade pip
    - python3 -m pip install --user ansible==8.7.0
    - mkdir -p ~/.ssh
    - export ANSIBLE_HOST_KEY_CHECKING=False   # known_hosts 충돌 방지
    # 키 주입(권장: 변수 사용)
    - |
      if [ -n "${ANSIBLE_PRIVATE_KEY_B64:-}" ]; then
        echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
      elif [ -f ~/.ssh/mykey ]; then
        # (대안) 러너에 미리 둔 키 사용
        cp ~/.ssh/mykey ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
      fi
  script:
    - |
      set -e
      # 0) 변경 없으면 스킵
      if [ ! -f .changed ]; then
        echo "No infra changes; skip Ansible."
        exit 0
      fi

      # 1) 접속 대상 IP (floating_ip 우선)
      TARGET_HOST=$(terraform output -raw floating_ip 2>/dev/null || true)
      if [ -z "$TARGET_HOST" ] || [ "$TARGET_HOST" = "null" ]; then
        TARGET_HOST=$(terraform output -raw instance_ip 2>/dev/null || true)
      fi
      [ -z "$TARGET_HOST" ] || [ "$TARGET_HOST" = "null" ] && { echo "ERROR: no target IP"; exit 1; }
      echo "TARGET_HOST=$TARGET_HOST"

      ANS_USER="${ANSIBLE_USER:-ubuntu}"

      # 2) 기존 호스트키 제거 후 새 키 등록(재활용 IP 대비)
      ssh-keygen -R "$TARGET_HOST" -f ~/.ssh/known_hosts 2>/dev/null || true
      ssh-keyscan -T 5 -H "$TARGET_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

      # 3) SSH 열릴 때까지 대기 (포트 22, 최대 5분)
      ansible -i localhost, all -c local -m wait_for -a "host=${TARGET_HOST} port=22 delay=2 timeout=300 state=started"

      # 4) 키 유무에 따라 옵션 분기
      if [ -f ~/.ssh/id_rsa ]; then
        SSH_ARGS="--private-key ~/.ssh/id_rsa"; EXTRA=""
      else
        SSH_ARGS=""; EXTRA='-e ansible_ssh_common_args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"'
      fi

      # 5) 연결 확인(3회 재시도)
      n=0
      until [ $n -ge 3 ]; do
        if ansible -i "$TARGET_HOST," all -u "$ANS_USER" $SSH_ARGS $EXTRA -m ping; then
          break
        fi
        n=$((n+1)); echo "Retrying ansible ping ($n/3)…"; sleep 5
      done
      [ $n -lt 3 ] || { echo "Ansible ping failed after retries"; exit 1; }

      # 6) 플레이북 실행 순서: hosts-fix → nginx → jenkins
      ansible-playbook -i "$TARGET_HOST," -u "$ANS_USER" $SSH_ARGS $EXTRA "$CI_PROJECT_DIR/${ANSIBLE_DIR}/hosts-fix.yml"
      ansible-playbook -i "$TARGET_HOST," -u "$ANS_USER" $SSH_ARGS $EXTRA "$CI_PROJECT_DIR/${ANSIBLE_DIR}/nginx-install.yml"
      ansible-playbook -i "$TARGET_HOST," -u "$ANS_USER" $SSH_ARGS $EXTRA "$CI_PROJECT_DIR/${ANSIBLE_DIR}/jenkins-install.yml"

# (옵션) MAIN 브랜치: Ansible만 수동 재실행
tf:ansible:manual:
  stage: configure
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  needs: ["tf:apply"]
  dependencies: ["tf:apply"]
  before_script:
    - *tf_setup
    - export PATH="$HOME/.local/bin:$PATH"
    - python3 -m pip install --user --upgrade pip
    - python3 -m pip install --user ansible==8.7.0
    - mkdir -p ~/.ssh
    - export ANSIBLE_HOST_KEY_CHECKING=False
    - |
      if [ -n "${ANSIBLE_PRIVATE_KEY_B64:-}" ]; then
        echo "$ANSIBLE_PRIVATE_KEY_B64" | base64 -d > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
      elif [ -f ~/.ssh/mykey ]; then
        cp ~/.ssh/mykey ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
      fi
  script:
    - |
      set -e
      TARGET_HOST=$(terraform output -raw floating_ip 2>/dev/null || true)
      if [ -z "$TARGET_HOST" ] || [ "$TARGET_HOST" = "null" ]; then
        TARGET_HOST=$(terraform output -raw instance_ip 2>/dev/null || true)
      fi
      [ -z "$TARGET_HOST" ] || [ "$TARGET_HOST" = "null" ] && { echo "No target IP"; exit 1; }
      echo "TARGET_HOST=$TARGET_HOST"

      ANS_USER="${ANSIBLE_USER:-ubuntu}"

      ssh-keygen -R "$TARGET_HOST" -f ~/.ssh/known_hosts 2>/dev/null || true
      ssh-keyscan -T 5 -H "$TARGET_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

      ansible -i localhost, all -c local -m wait_for -a "host=${TARGET_HOST} port=22 delay=2 timeout=300 state=started"

      if [ -f ~/.ssh/id_rsa ]; then
        SSH_ARGS="--private-key ~/.ssh/id_rsa"; EXTRA=""
      else
        SSH_ARGS=""; EXTRA='-e ansible_ssh_common_args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"'
      fi

      ansible -i "$TARGET_HOST," all -u "$ANS_USER" $SSH_ARGS $EXTRA -m ping
      ansible-playbook -i "$TARGET_HOST," -u "$ANS_USER" $SSH_ARGS $EXTRA "$CI_PROJECT_DIR/${ANSIBLE_DIR}/hosts-fix.yml"
      ansible-playbook -i "$TARGET_HOST," -u "$ANS_USER" $SSH_ARGS $EXTRA "$CI_PROJECT_DIR/${ANSIBLE_DIR}/nginx-install.yml"
      ansible-playbook -i "$TARGET_HOST," -u "$ANS_USER" $SSH_ARGS $EXTRA "$CI_PROJECT_DIR/${ANSIBLE_DIR}/jenkins-install.yml"

# ─────────────────────────────────────────────────────────
# MAIN 브랜치: destroy (환경변수로 이중 안전장치)
tf:destroy:
  stage: destroy
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  when: manual
  allow_failure: false
  dependencies: ["tf:apply"]     # apply 아티팩트(state) 받아서 파괴
  before_script:
    - *tf_setup
  script:
    - |
      if [ -z "${DESTROY_OK:-}" ]; then
        echo "DESTROY_OK variable not set, aborting"; exit 1
      fi
      terraform state list || true
      echo "Destroy confirmed: $DESTROY_OK"
      terraform destroy -auto-approve -lock-timeout=60s



```

## 인벤토리 방식 비교

### 기존 방식 (inventory 파일)
- `inventory.ini` 파일에 그룹별 서버 정의
- 플레이북에서 `hosts: web` 등 그룹 지정
- **문제점**: CI/CD에서 인벤토리 파일 갱신 누락 시 IP 불일치 발생

### 현재 방식 (콤마 인벤토리)
- Terraform output에서 IP 직접 추출
- `-i "${TARGET_IP},"` 방식으로 단일 서버 지정
- 플레이북은 `hosts: all`로 통일
- **장점**: 인벤토리 파일 불필요, 동기화 문제 완전 해결

## 실행 흐름

1. **Plan 단계**: Terraform 계획 생성 및 검증
2. **Apply 단계**: VM 생성 후 IP 추출하여 환경변수로 전달
3. **Config 단계**: 추출된 IP로 Ansible 플레이북 자동 실행
   - hosts-fix.yml: 호스트명 및 DNS 설정
   - nginx.yml: Nginx 설치 및 구동
   - jenkins.yml: Jenkins 설치 및 구동
4. **Manual Config**: 필요 시 수동으로 특정 플레이북만 재실행 가능

## 핵심 특징

- **완전 자동화**: Terraform apply 후 Ansible이 자동 실행됨
- **IP 동기화 문제 해결**: 콤마 인벤토리로 실시간 IP 전달
- **재실행 가능**: 수동 Job으로 필요시 재설정 가능
- **보안**: SSH 키 Base64 인코딩으로 안전하게 관리
