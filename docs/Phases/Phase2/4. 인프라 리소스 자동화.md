# OpenStack Terraform 인프라 구성 가이드

Terraform을 활용해 OpenStack 인프라를 확장하여 외부에서 접근 가능한 VM 인스턴스를 자동으로 구성함

---

## 사전 준비

### 기존 인스턴스 정리
이전 단계에서 생성한 인스턴스가 있다면 먼저 삭제함:

```bash
terraform destroy -auto-approve
```

---

## Ubuntu Cloud Image 준비

### 1. Ubuntu 이미지 다운로드
OpenStack에서 사용할 qcow2 이미지를 다운로드함:

```bash
wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img
```

### 2. 이미지 커스터마이징 (Optional)
root 로그인을 위한 설정 (필요한 경우):

```bash
sudo virt-customize -a jammy-server-cloudimg-amd64.img \
  --root-password password:1234 \
  --run-command 'useradd -m -s /bin/bash ubuntu || true' \
  --run-command 'echo "ubuntu:1234" | chpasswd' \
  --install openssh-server \
  --run-command 'mkdir -p /etc/ssh/sshd_config.d' \
  --run-command 'printf "PermitRootLogin yes\nPasswordAuthentication yes\n" > /etc/ssh/sshd_config.d/99-local.conf' \
  --run-command 'sed -i "s/^#\?PermitRootLogin.*/PermitRootLogin yes/" /etc/ssh/sshd_config || true' \
  --run-command 'sed -i "s/^#\?PasswordAuthentication.*/PasswordAuthentication yes/" /etc/ssh/sshd_config || true' \
  --run-command 'systemctl enable ssh || true' \
  --run-command 'touch /etc/cloud/cloud-init.disabled'
```

### 3. 이미지 등록 (CLI)

```bash
openstack image create "ubuntu-22.04" \
  --file jammy-server-cloudimg-amd64.img \
  --disk-format qcow2 \
  --container-format bare \
  --public
```

**기존 이미지가 있는 경우:**
```bash
openstack image delete ubuntu-22.04
```

### 4. 업로드한 이미지 확인 (이름/UUID 확인)

```bash
openstack image list
```

---

## SSH 키페어 생성 및 등록

### 1. SSH 키 생성
`.ssh` 디렉토리를 먼저 생성하고 키를 생성함:

```bash
mkdir -p ~/.ssh
ssh-keygen -t rsa -b 4096 -f ~/.ssh/mykey
```

### 2. OpenStack 키페어 등록

```bash
openstack keypair create --public-key ~/.ssh/mykey.pub mykey
```

### 3. 키페어 확인
정상적으로 생성되었는지 확인함:

```bash
ls -l ~/.ssh/mykey*
```

키페어 목록 확인

```bash
openstack keypair list
```

---

## Terraform 코드 구성

### `provider.tf`
Terraform 프로바이더 설정:

```hcl
terraform {
  required_providers {
    openstack = {
      source  = "terraform-provider-openstack/openstack"
      version = "~> 1.51.1"
    }
  }
}

provider "openstack" {
  cloud = "devstack"
}
```

### `variables.tf`
변수 정의:

```hcl
# 인스턴스 관련
variable "instance_name" {
  description = "인스턴스 이름"
  default     = "tf-instance"
}

variable "image_id" {
  description = "이미지 UUID"
  default     = "d714507c-3a35-4020-ac27-c58fa93ac4f3"
}

variable "flavor_name" {
  description = "사용할 flavor"
  default     = "m1.medium"
}

variable "key_name" {
  description = "SSH key pair 이름"
  default     = "mykey"
}

variable "volume_size" {
  description = "루트 볼륨 크기 (GiB)"
  default     = 60
}

# 네트워크 관련
variable "network_name" {
  description = "내부 네트워크 이름"
  default     = "shared"
}

variable "subnet_name" {
  description = "내부 서브넷 이름"
  default     = "shared-subnet"
}
```

### `main.tf`
메인 리소스 정의:

```hcl# 외부(public) 네트워크 정보 가져오기 (Floating IP용)
data "openstack_networking_network_v2" "public" {
  name = "public"
}

# 내부 서브넷 정보 가져오기 (예: shared-subnet)
data "openstack_networking_subnet_v2" "internal_subnet" {
  name = var.subnet_name
}

# 라우터 생성 (내부 ↔ 외부 통신)
resource "openstack_networking_router_v2" "router1" {
  name                = "router1"
  external_network_id = data.openstack_networking_network_v2.public.id
}

# 라우터에 내부 서브넷 연결
resource "openstack_networking_router_interface_v2" "router_interface" {
  router_id = openstack_networking_router_v2.router1.id
  subnet_id = data.openstack_networking_subnet_v2.internal_subnet.id
}

# 보안 그룹 생성 (SSH, ping, HTTP 허용)
resource "openstack_networking_secgroup_v2" "secgroup_ssh" {
  name = "allow_ssh_icmp_http"
}

resource "openstack_networking_secgroup_rule_v2" "secgroup_rule_ssh" {
  direction         = "ingress"
  ethertype         = "IPv4"
  protocol          = "tcp"
  port_range_min    = 22
  port_range_max    = 22
  remote_ip_prefix  = "0.0.0.0/0"
  security_group_id = openstack_networking_secgroup_v2.secgroup_ssh.id
}

resource "openstack_networking_secgroup_rule_v2" "secgroup_rule_icmp" {
  direction         = "ingress"
  ethertype         = "IPv4"
  protocol          = "icmp"
  remote_ip_prefix  = "0.0.0.0/0"
  security_group_id = openstack_networking_secgroup_v2.secgroup_ssh.id
}

resource "openstack_networking_secgroup_rule_v2" "secgroup_rule_http" {
  direction         = "ingress"
  ethertype         = "IPv4"
  protocol          = "tcp"
  port_range_min    = 80
  port_range_max    = 80
  remote_ip_prefix  = "0.0.0.0/0"
  security_group_id = openstack_networking_secgroup_v2.secgroup_ssh.id
}

resource "openstack_networking_secgroup_rule_v2" "secgroup_rule_jenkins" {
  direction         = "ingress"
  ethertype         = "IPv4"
  protocol          = "tcp"
  port_range_min    = 8080
  port_range_max    = 8080
  remote_ip_prefix  = "0.0.0.0/0"
  security_group_id = openstack_networking_secgroup_v2.secgroup_ssh.id
}

resource "openstack_networking_secgroup_rule_v2" "secgroup_rule_gitlab" {
  direction         = "ingress"
  ethertype         = "IPv4"
  protocol          = "tcp"
  port_range_min    = 8081
  port_range_max    = 8081
  remote_ip_prefix  = "0.0.0.0/0"
  security_group_id = openstack_networking_secgroup_v2.secgroup_ssh.id
}


# Floating IP 생성
resource "openstack_networking_floatingip_v2" "fip_1" {
  pool = data.openstack_networking_network_v2.public.name
}

# 인스턴스 생성 (볼륨 부팅, 삭제 시 볼륨도 삭제됨)
resource "openstack_compute_instance_v2" "vm_1" {
  name        = var.instance_name
  flavor_name = var.flavor_name
  key_pair    = var.key_name

  block_device {
    uuid                = var.image_id
    source_type         = "image"
    destination_type    = "volume"
    volume_size         = var.volume_size
    delete_on_termination = true
    boot_index          = 0
  }

  network {
    name = var.network_name
  }

  security_groups = [openstack_networking_secgroup_v2.secgroup_ssh.name]
}

# Floating IP 연결
resource "openstack_compute_floatingip_associate_v2" "fip_assoc_1" {
  floating_ip = openstack_networking_floatingip_v2.fip_1.address
  instance_id = openstack_compute_instance_v2.vm_1.id
}
```

### `outputs.tf`
출력 변수 정의:

```hcl
output "instance_ip" {
  description = "인스턴스 내부 IP"
  value       = openstack_compute_instance_v2.vm_1.access_ip_v4
}

output "floating_ip" {
  description = "VM의 Floating IP 주소"
  value       = openstack_networking_floatingip_v2.fip_1.address
}
```

---

## 배포 및 테스트

### 1. Terraform 초기화 및 배포

```bash
# Terraform 초기화
terraform init

# 실행 계획 확인
terraform plan

# 인프라 배포
terraform apply
```

### 2. Floating IP 확인

```bash
terraform output floating_ip
```

### 3. SSH 접속

**SSH 키를 이용한 접속:**
```bash
ssh -i ~/.ssh/mykey ubuntu@<floating_ip>
```

---

## 웹서버 설치

SSH 접속 후 Nginx 웹서버를 설치하여 HTTP 연결을 테스트함:

```bash
# 패키지 업데이트
sudo apt update
sudo apt upgrade -y

# Nginx 설치
sudo apt install -y nginx

# Nginx 서비스 시작 및 활성화
sudo systemctl start nginx
sudo systemctl enable nginx

# 상태 확인
sudo systemctl status nginx
```

웹 브라우저에서 `http://<floating_ip>`로 접속하여 Nginx 기본 페이지를 확인함

---

## 검증 포인트

다음 항목들을 확인하여 배포가 정상적으로 완료되었는지 검증함:

- **DevStack 대시보드**: `https://a.b.c.d/dashboard`에서 생성된 리소스 확인
- **보안 그룹**: SSH(22), ICMP, HTTP(80) 포트가 올바르게 허용되었는지 확인
- **Floating IP**: 인스턴스에 정상 할당되었는지 확인
- **SSH 접속**: 외부에서 SSH 접속이 정상 작동하는지 확인
- **웹 서비스**: HTTP 접속을 통한 웹페이지 접근 가능 여부 확인
- **네트워크 연결**: ping 테스트로 네트워크 연결 상태 확인

---

## 트러블슈팅

### 인스턴스 생성 후 IP 주소가 할당되지 않는 경우

**문제**: 처음 인스턴스 생성 시 네트워크 인터페이스에 IP 주소가 할당되지 않음

**해결 방법**: 네트워크 인터페이스를 수동으로 활성화하고 IP 주소를 갱신

```bash
sudo ip link set ens3 up
sudo dhclient ens3
```

### apt update 실패 시

**문제**: 패키지 업데이트가 실패하는 경우

**해결 단계**:

1. **네트워크 상태 확인**
   ```bash
   ping 8.8.8.8
   ```
   핑이 성공한다면 네트워크 연결은 정상

2. **DNS 설정 확인 및 수정**
   ```bash
   cat /etc/resolv.conf
   ```

3. **DNS 서버 추가** (파일이 비어있거나 잘못된 경우)
   ```bash
   sudo vi /etc/resolv.conf
   ```
   파일 맨 위에 다음 내용 추가:
   ```
   nameserver 8.8.8.8
   nameserver 8.8.4.4
   ```

**참고**: resolv.conf 파일은 시스템 재부팅 시 초기화될 수 있으므로, 영구적인 DNS 설정을 원하면 netplan 설정을 수정해야 함

---
