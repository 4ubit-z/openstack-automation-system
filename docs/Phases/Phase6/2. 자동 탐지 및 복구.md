# Phase 6-2: 자동 탐지 및 복구

본 문서는 Phase 6-1에서 수행한 부하 및 장애 주입을 Prometheus/Alertmanager로 탐지하고, Jenkins가 자동으로 복구 스크립트를 실행하도록 구성하는 과정을 다룬다.

## 사전 준비사항

다음 구성요소들이 설치 및 설정되어 있어야 한다:

- Prometheus, Alertmanager, Grafana 설치 완료
- Node Exporter 설치 완료 (잡 이름: **nodes**)
- Blackbox Exporter 설치 완료 (선택사항)
- Jenkins 설치 및 **Generic Webhook Trigger** 플러그인 준비
- Jenkins와 Nginx가 동일 VM에 설치된 환경

## Prometheus 기본 설정

`/etc/prometheus/prometheus.yml`에 다음 섹션이 포함되어야 한다:

```yaml
alerting:
  alertmanagers:
    - static_configs:
        - targets: ['localhost:9096']   # Alertmanager 포트

rule_files:
  - /etc/prometheus/rules/*.yml        # 규칙 파일 경로
```

모든 규칙 파일은 `/etc/prometheus/rules/` 디렉토리 아래에 배치한다.

## 1단계: Prometheus 알람 규칙 정의

### 노드 기본 알람 설정

`/etc/prometheus/rules/node-alerts.yml` 파일을 생성한다:

```yaml
groups:
- name: node-basics
  rules:
  - alert: NodeDown
    expr: up{job="nodes"} == 0
    for: 1m
    labels: {severity: critical}
    annotations:
      summary: "Node down: {{ $labels.instance }}"

  - alert: HighCPULoad
    expr: 100 - (avg by (instance) (rate(node_cpu_seconds_total{job="nodes",mode="idle"}[5m])) * 100) > 85
    for: 5m
    labels: {severity: warning}
    annotations:
      summary: "High CPU on {{ $labels.instance }}"
```

규칙 적용 및 검증:

```bash
sudo promtool check rules /etc/prometheus/rules/node-alerts.yml
sudo systemctl reload prometheus
```

### 서비스 상태 알람 설정

Node Exporter가 systemd 콜렉터로 실행 중이어야 한다 (`--collector.systemd` 옵션).

`/etc/prometheus/rules/service-alerts.yml` 파일을 생성한다:

```yaml
groups:
- name: service-alerts
  rules:
  - alert: NginxDown
    expr: node_systemd_unit_state{name="nginx.service",state="active"} == 0
    for: 1m
    labels: {severity: critical}
    annotations:
      summary: "Nginx DOWN on {{ $labels.instance }}"
      description: "nginx.service is not active."
```

적용 및 검증:

```bash
sudo promtool check rules /etc/prometheus/rules/service-alerts.yml
sudo systemctl reload prometheus
```

### HTTP 가용성 알람 설정 (선택사항)

Blackbox Exporter를 사용하는 경우, `/etc/prometheus/prometheus.yml`에 스크레이프 설정을 추가한다:

```yaml
scrape_configs:
  - job_name: blackbox_http
    metrics_path: /probe
    params:
      module: [http_2xx]
    static_configs:
      - targets:
        - http://127.0.0.1/
    relabel_configs:
      - source_labels: [__address__]
        target_label: __param_target
      - source_labels: [__param_target]
        target_label: instance
      - target_label: __address__
        replacement: 127.0.0.1:9115   # blackbox_exporter 주소
```

HTTP 알람 규칙 파일 `/etc/prometheus/rules/http-alerts.yml`을 생성한다:

```yaml
groups:
- name: http-alerts
  rules:
  - alert: HTTPDown
    expr: probe_success{job="blackbox_http"} == 0
    for: 1m
    labels: {severity: critical}
    annotations:
      summary: "HTTP DOWN {{ $labels.instance }}"
      description: "Blackbox probe failed (no HTTP 2xx)."
```

적용 및 검증:

```bash
sudo promtool check rules /etc/prometheus/rules/http-alerts.yml
sudo systemctl reload prometheus
```

## 2단계: Alertmanager 웹훅 설정

`/etc/alertmanager/alertmanager.yml` 파일을 설정한다:

```yaml
route:
  receiver: 'jenkins'
  group_by: ['alertname','instance']
  group_wait: 10s
  group_interval: 1m
  repeat_interval: 2h

receivers:
- name: 'jenkins'
  webhook_configs:
  - url: 'http://<JENKINS_IP>:8080/generic-webhook-trigger/invoke?token=ALERT_TOKEN_123'
    send_resolved: true
```

설정 적용:

```bash
sudo systemctl restart prometheus-alertmanager
```

**주의사항**: Alertmanager가 `:9096` 포트에서 리슨하고 있는지 확인한다 (`ss -lntp | grep 9096`).

## 3단계: Jenkins 자동복구 Job 생성

### 사전 준비

1. **Generic Webhook Trigger** 플러그인을 설치한다
2. 새로운 Pipeline Job을 생성한다 (이름: `auto-recover`)

### 트리거 설정

Generic Webhook Trigger에서 다음 변수 매핑을 설정한다:

- `$.alerts[0].labels.alertname` → `ALERT_NAME`
- `$.status` → `STATUS`

### 파이프라인 스크립트

다음 파이프라인 스크립트를 입력한다:

```groovy
pipeline {
  agent any
  options { timestamps() }
  triggers {
    GenericTrigger(
      genericVariables: [
        [key: 'ALERT_NAME', value: '$.alerts[0].labels.alertname'],
        [key: 'STATUS',     value: '$.status']
      ],
      token: 'ALERT_TOKEN_123',
      printContributedVariables: true,
      printPostContent: true
    )
  }
  stages {
    stage('Remediate') {
      steps {
        script {
          if (env.STATUS == 'firing') {
            if (env.ALERT_NAME == 'NginxDown') {
              sh 'sudo systemctl start nginx || true'
            } else if (env.ALERT_NAME == 'HTTPDown') {
              sh '''
                sudo iptables -D INPUT -p tcp --dport 80 -j DROP || true
                sudo systemctl start nginx || true
              '''
            } else if (env.ALERT_NAME == 'HighCPULoad') {
              sh 'pkill -f "while :; do :; done" || true'
            } else if (env.ALERT_NAME == 'NodeDown') {
              echo 'NodeDown은 전체 노드 이슈로 자동조치하지 않고 알림만 수행한다.'
            } else {
              echo "No remediation defined for ${env.ALERT_NAME}"
            }
          } else {
            echo "Alert ${env.ALERT_NAME} resolved, no action needed."
          }
        }
      }
    }
  }
}
```

웹훅 URL 예시:
```
http://<JENKINS_IP>:8080/generic-webhook-trigger/invoke?token=ALERT_TOKEN_123
```

## 알람별 복구 매핑 요약

| 알람명 | 조건/트리거 | Jenkins 대응 스크립트 |
|--------|------------|---------------------|
| NodeDown | `up{job="nodes"} == 0` | 자동 조치 없음 (전체 노드 이슈) |
| NginxDown | `node_systemd_unit_state{name="nginx.service",state="active"} == 0` | `systemctl start nginx` |
| HTTPDown | `probe_success{job="blackbox_http"} == 0` | `iptables -D INPUT 80` 제거 + `systemctl start nginx` |
| HighCPULoad | CPU > 85% (5분간) | `pkill -f "while :; do :; done"` (스파이크 종료) |

## 테스트 시나리오

### 시나리오 1: CPU 스파이크

```bash
timeout 120 bash -c 'while :; do :; done' &
```

예상 흐름:
1. Prometheus: `HighCPULoad` (5분 기준) → firing
2. Alertmanager → Jenkins 웹훅 → 자동 복구
3. Grafana: CPU 정상화 확인

### 시나리오 2: Nginx 다운

```bash
sudo systemctl stop nginx
```

예상 흐름:
1. Prometheus: `NginxDown` firing
2. Jenkins: nginx 시작 → 복구

### 시나리오 3: 포트 차단

```bash
sudo iptables -I INPUT -p tcp --dport 80 -j DROP
```

예상 흐름:
1. Blackbox: `HTTPDown` firing
2. Jenkins: DROP 규칙 제거 + nginx 시작 → 복구

### 시나리오 4: 노드 다운 (선택사항)

Node Exporter 잡명 `nodes` 대상으로 스크레이프가 끊기도록 일시 차단한다.

예상 흐름:
1. `NodeDown` firing → 알림만 (자동조치 없음)

## 트러블슈팅

### 일반적인 문제 및 해결방법

**`node_systemd_unit_state` 메트릭 미수집**
- Node Exporter 실행옵션에 `--collector.systemd` 추가

**Alertmanager 연결 실패**
- `prometheus.yml`의 `alerting.targets`와 실제 리슨 포트(`9096`) 일치 확인

**Jenkins 권한 문제**
- 복구 명령에 `sudo` 사용 및 NOPASSWD 설정 고려

**HTTPDown 알람 미발생**
- Blackbox Exporter 스크레이프 설정 및 타겟 URL 확인

## 결론

본 문서에서 구성한 시스템은 다음과 같은 흐름으로 작동한다:

1. **부하 테스트**: Phase 6-1의 `load-test` Job으로 부하 생성
2. **자동 복구**: Phase 6-2의 `auto-recover` Job으로 장애 복구
3. **모니터링 흐름**: Prometheus가 감지 → Alertmanager가 통지 → Jenkins가 복구 → Grafana/Alerts로 정상화 확인

이를 통해 장애 상황에 대한 자동화된 대응 체계를 구축할 수 있다.
